
from utils_ga import *

params_real_ga = {
    "f": lambda xs: sphere(0.5, xs),
    "minimization": True,
    "mutation_rate": 0.05,
    "crossover_rate": 0.9,
    "population_size": 200,  # should be ~200
    "generations": 200,  # should be ~300
    "gene_index": 4
}


def mutate_real_ga(child):
    """
    This function accepts a child (list of phenome values) and applies gaussian noise to a single element of list.
    :param child: child is represented by a list of 10 phenome values (3.12, 1.98, -0.23, etc)
    :return: child: returns the mutated child
    """
    x = gauss(0, 0.8)
    random_index = randrange(0,10)

    if child[random_index] + x < 5.12:
        child[random_index] =  round(child[random_index] + x, 2)
    else: child[random_index] =  round(child[random_index] - x, 2)

    return child


def reproduce_real_ga(parent1, parent2, params):
    """
    This function is the 'real' reproduction function (based on the Phenome values) of the Genetic Algorithm.
    It takes 2 parents and applies a crossover function to swap sections of each parent element to create 2 children
    and then potentially mutates them. The mutation applies Gaussian noise to one Phenome value for each child.
    Crossover and mutation functions are conditional on the crossover and mutation rates passed in as parameters.

    :param parent1: 2 parents will reproduce 2 children or be returned themselves
    each parent has fields: parent[PHENOME] ex: [0.53, 0.48...] and
    parent[FITNESS]
    :param parent2: same as above
    :param params: specific binary ga macro parameters including gene_index, # of gens, population size, etc
    :return: child1, child2: children will be returned after possible mutation, otherwise parents returned
    """
    gene_index = params["gene_index"]
    # if random number greater than crossover rate return parents
    if params["crossover_rate"] < random():
        return parent1[PHENOME], parent2[PHENOME]

    # perform crossover functions
    child1 = parent1[PHENOME][:gene_index] + parent2[PHENOME][gene_index:]
    child2 = parent2[PHENOME][:gene_index] + parent1[PHENOME][gene_index:]

    # mutate children based on the mutation rate and random number
    if params["mutation_rate"] < random():
        child1 = mutate_real_ga(child1)
    if params["mutation_rate"] < random():
        child2 = mutate_real_ga(child2)

    return child1, child2


def real_ga(params, debug=False):
    """
    This function is the main function of the Genetic Algorithm using real values. The function initially generates a
    random population where each element consists of 10 Phenome values. Then for each generation evaluates the
    population assigning a fitness score to each element based on the Sphere Function.

    In each generation the population reproduces a subsequent generation is generated by executing crossover and
    mutation functions on the parent elements.

    Best fitting element is calculated for each generation and also the best overall element.
    Debug option will print the best solution for 20 generations throughout the algorithm execution.

    :param params: child is represented by a list of 10 phenome values (3.12, 1.98, -0.23, etc)
    :param debug: if True function will print the best fitting element for 20 equally spaced iterations of the loop
    :return: child: returns the mutated child
    """
    N = params["generations"]
    population = generate_random_population(N)
    best_fit = (0, [])

    for gen in range(N):
        next_gen = []
        # evaluate the population, append fitness score
        evaluated_population = [( 1 - sphere(0.5, x), x) for x in population]
        best_fit_this_gen = sorted(evaluated_population, reverse=True)[0]

        if debug and gen % int(N / 20) == 0:
            print(f'Gen {gen}:', to_print_dict(best_fit_this_gen))

        for _ in range(int(params["population_size"]/2)):
            # pick 2 fittest elements from random sample of 7 from population
            parent1, parent2 = sorted(sample(evaluated_population, 7), reverse=True)[:2]
            # reproduce for children
            child1, child2 = reproduce_real_ga(parent1, parent2, params)
            # add children to next gen
            next_gen.extend([child1, child2])

        if best_fit[FITNESS_SCORE] < best_fit_this_gen[FITNESS_SCORE]:
            best_fit = best_fit_this_gen
        population = next_gen

    return to_print_dict(best_fit)


if __name__ == '__main__':

    print('######################\nREAL GENETIC ALGORITHM\n######################')
    real_ga(params_real_ga, True)
